# shell 脚本编程基础

## shell 编程概述

shell 本身是一个用 C 语言编写的程序，是连接 用户 和 UNIX/Linux 内核 的桥梁。

一个简单的shell脚本 `ShowHello.sh` （Linux脚本一般使用 `.sh` 作为文件后缀名）：

``` shell
#! /bin/bash
#ShowHello
#To show hello to somebody
echo -n "Enter your name:"
read name
echo "Hello, $name"
```

- 第一行 `#! /bin/bash` 这是一个特殊的标记（称为 shebang），告诉系统这个脚本需要用 `/bin/bash` 这个程序来执行，是 shell 脚本的标准开头。通常放在脚本第一行，从而调用相应的解释程序予以执行
- 第二行 `#ShowHello` 和第三行 `#To show hello to somebody` 以 `#` 开头的行是注释，不会被执行，用来解释脚本的功能
- 第四行 `echo -n "Enter your name:"` echo 是输出文字的命令，-n 选项表示输出后不自动换行。这行的效果是在屏幕上显示 "Enter your name:"，光标会停在冒号后面等待输入
- 第五行 `read name` read 命令用来接收用户从键盘输入的内容，这里把输入的内容保存到变量 name 中。比如你输入 "Tom"，那么 name 这个变量就代表 "Tom"
- 第六行 `echo "Hello, $name"` 再次使用 echo 输出内容，$name 表示取出变量 name 中保存的值。如果之前输入了 "Tom"，这行就会输出 "Hello, Tom"

这个shell脚本还不能运行，因为它没有 `x` 权限，无法作为应用程序执行。为这个脚本的所有者 `u` 添加 `x` 权限 `$ chomd u+x ShowHello.sh`

Linux 中，创建文件默认是不可执行的文件，需要修改文件的权限，为文件增加可执行权限，后在命令行模式下直接输入该文件的相对路径 ./文件名，即可运行

``` bash
$ vim ShowHello.sh
$ ./ShowHello.sh
-bash: ./ShowHello.sh: Permission denied
$ ls -l
total 8
-rw-r--r-- 1 d111kc d111kc  108 Jul 31 20:23 ShowHello.sh
-rw-r--r-- 1 d111kc d111kc    0 Jul 30 21:05 note1.txt
drwxr-xr-x 2 d111kc d111kc 4096 Jul 30 21:04 test1
$ chmod u+x ShowHello.sh
$ ./ShowHello.sh
Enter your name:Mike
Hello, Mike
```

## shell 的种类

shell脚本的第一行需要指出该脚本的解释程序，即shell的种类。Linux系统提供了多种不同的shell。

查看Linux系统提供的shell种类：

``` bash
$ cat /etc/shells
# /etc/shells: valid login shells
/bin/sh
/usr/bin/sh
/bin/bash
/usr/bin/bash
/bin/rbash
/usr/bin/rbash
/usr/bin/dash
/usr/bin/tmux
```

最常见的shell有Bourne shell（简称sh）、C shell（简称csh）、Korn shell（简称ksh）和Bourne-again shell（简称bash）。默认的shell是bash，它具有以下优点：

- 命令记忆功能 通过键盘上的上下箭头可以快速输入之前输入过的命令
- Tab自动补全
- 设置别名功能 例如 `$ alias ll='ls -l'` 可以将 `ls -l`的别名设置为 `ll`

## shell 脚本的运行

有3中方式执行shell脚本：

### 方式一

将shell脚本的权限设置为可执行，然后在提示符下直接运行。脚本文件的编辑完成后，利用chmod命令修改脚本文件的权限为可执行，如前面的示例：

``` bash
$ chmod u+x ShowHello.sh
$ ./ShowHello.sh
```

在运行该脚本时，必须给出该脚本的相对路径（如 `./ShowHello.sh`，这个相对路径不能省略 `./`）或绝对路径。在执行系统命令时，只需要给出命令文件名。因为命令和用户的可执行脚本文件是否能够执行，与环境变量PATH有关。

查看环境变量PATH `$ echo $PATH`

环境变量PATH的值决定了shell将到哪些目录中寻找命令或可执行程序，当用户运行一个命令或可执行程序时，Linux在这些目录下按顺序依次搜寻。由于用户的可执行脚本是放在用户家目录下的，所以直接输入 `ShowHello.sh`，系统无法找到该文件。

通过这种方式运行脚本，脚本文件第一行的`#！/bin/bash`一定要写对，好让系统查找到正确的解释器。

### 方式二

以脚本名作为参数传递给shell程序。

``` bash
$ bash ShowHello.sh
Enter your name:Mike
Hello, Mike
```

这种执行方式就是运行bash，将脚本 `ShowHello.sh` 作为参数传递给bash。通过这种方式运行脚本，不需要在脚本文件的第一行指定解释器信息，并且脚本名后面还可以带参数。

### 方式三（不推荐使用）

将脚本以输入重定向的方式传递给bash。

运行bash程序，以输入重定向的方式让bash从给定文件中读入命令行，并进行相应处理。

``` bash
d111kc@D111KC:~$ bash < ShowHello.sh
Enter your name:d111kc@D111KC:~$
```

这种方式的脚本后面是不能带参数的

## shell 基础

shell脚本是文本文件

### 通配符

文件名的扩展称为通配（Globbing）

- `*` 匹配任意字符（不包括路径分隔符`/`）的 0 次或多次出现
- `?` 匹配任意单个字符（不包括 `/`）
- `[]` 将一组字符列表括起来，其作用是匹配该列表中的任意一个字符。例如，`space.[co]`匹配`space.c`或者`space.o`，`[Hh]*`匹配以“H"或“h”开头的文件名。`[]`中无论有几个字符，都只代表某一个字符。在`[]`中，可以使用 `-` 指定字符的范围，例如`[0-9]`匹配任何0至9的数字。
- `[^]` 或 `[!]` 为了匹配不在列表中的字符，需要在列表的开头加一个`^`或者`!`，代表反向选择。例如，`[^Hh]*`和`[!Hh]*`匹配以非“H"或“h”开头的文件名。
- `{stringl,string2,...}` 匹配 sringl或 string2（或更多）中的一个字符串。`{}`告诉shell依次使用每种string形成一个单独的文件名进行匹配，大括号扩展只适用于bash、tcsh和Cshell，不适用于Kornshell和FreeBSDshell。例如，用户希望查看目录/home/student，/home/cs1，/home/re中所有文件的名称，`$ ls /home/student /home/cs1 /home/re`
使用通配符命令就比较简单：`$ ls /home/{student,cs1,re}` 大括号中的逗号前面和后面都不能有空格

### 转义字符

shell默认支持转义字符，如果是特殊字符想要表示字面意义需要在前面添加 `\` 转义

### 引号

shell 中引用字符有 3 种：单引号`''`，双引号`""`和反引号`

1. 单引号引用一串字符，所有字符都是普通字符

#### 单引号

被单引号括起来的所有字符都是普通字符，就算特殊字符也不再有特殊含义。在某些时候，会希望使用个别特殊字符，如`$`来引用变量的值，例如：

``` bash
$ echo 'the directory is $HOME; the userid is $USER'
the directory is $HOME; the userid is $USER
```

很显然这样的输出并不是我们所需要的。这时命令就不能正常工作，在不使用转义字符 `\`（若命令中存在多个特殊字符，使用转义字符“\”会让命令可读性变差）时，双引号可以很好地解决这个问题。

#### 双引号

由双引号括起来的字符（除`$`、反引号和转义字符 `\` 外）均作为普通字符。“$”“\”和倒引号是拥有特殊含义的，“$”代表引用变量的值，而反引号代表引用命令。在上述例题中，采用双引号可以使 `$` 保留特殊含义

``` bash
d111kc@D111KC:~$ echo 'the directory is $HOME; the userid is $USER'
the directory is $HOME; the userid is $USER
d111kc@D111KC:~$ echo "the directory is $HOME; the userid is $USER"
the directory is /home/d111kc; the userid is d111kc
```

``` bash
$ name=d111kc
$ echo '$name'
$name
$ echo "$name"
d111kc
```

如果需要在双引号中间输出“$”和倒引号，则要在符号前加转义符“\”

#### 反引号

由反引号括起来的字符串被shell解释为命令行，shell会先执行该命令，并以它的标准输出结果取代整个倒引号部分。

``` bash
$ today=`date`
$ echo "Today is $today"
Today is Thu Jul 31 21:45:01 CST 2025
```

### 重定向符

shell重定向分为两种，一种是输入重定向，另一种是输出重定向。从字面上理解，输入/输出重定向就是改变输入与输出方向。

每个程序都有输入和输出，那么程序应该能够从任何源接受输入，并可以向任何目标输出。例如，一个排序程序可以选择从键盘输入文本，从已有文件中读取文本，或者读入另一个程序的输出结果。同样，排序程序应该能够在显示器上显示输出，将输出写入文件或者将输出发送给另一个程序做进一步处理。

这样的设计思想有一个突出的优点就是，当编写程序时，可以依靠Linux处理输入/输出，程序员不必考虑输入/输出的各种情况，只需处理输入/输出的内容，当程序真正开始运行时，shell会将程序连接到用户希望使用的输入和输出设备上。在程序员眼里，一切设备皆文件，他以一种通用的方式编写程序的读取和写人。为了实现这一思想，UNIX（Linux）的开发人员设计了一种读/写数据的通用方法，这些功能被称为标准I/O

在默认情况下，大多数程序都会从键盘读取输入，并将输出到显示器。因此在登录时，shell会自动地将程序的输入源设置为键盘，称为标准输入；设置程序运行的正确结果输出到显示器，称为标准输出；将程序运行中的出错信息输出位置也设置为显示器，称为标准错误。标准输入、标准输出和标准错误都以文件的方式存在，通常缩写为`stdin`、`stdout`和`stderr`。

每次输人命令，都可以告诉shell在此命令执行期间重新设置输人和输出的方向，这正是UNIX（Linux）功能强大的地方。

使用输出重定向符 `>` ，改变内容输出的位置：

``` bash
$ ls
ShowHello.sh  bash  name  note1.txt  test1
$ ls > filelist.txt
$ cat filelist.txt
ShowHello.sh
bash
filelist.txt
name
note1.txt
test1
```

上面的代码 `ls > filelist.txt` 将 `ls` 命令输出的内容到文件 `filelist.txt` 中

输人/输出方向就是数据的流动方向。输入方向就是数据从哪里流向程序。数据默认从键盘流向程序，如果改变了它的方向，数据就从其他地方流人，这就是输人重定向。输出方向就是数据从程序流向哪里。数据默认从程序流向显示器，如果改变了它的方向，数据就流向其他地方，这就是输出重定向。

常用的输入/输出重定向符：

- 标准输入重定向
    - `command < file` 将文件作为命令的输入
    - `command < 分界符`从标准输入中读入，直到遇见分界符才停止
- 标准错误输入重定向
    - `command 2 > file` 以覆盖的方式，把command的错误信息输出到file文件中
    - `command2 >> file`以追加的方式，把command的错误信息输出到file文件中
- 标准输出重定向
    - `command > file`以覆盖的方式，把command的正确输出结果输出到file文件中
    - `command >> file`以追加的方式，把command的正确输出结果输出到file文件中

#### 输入重定向符号 `<`

输入重定向符 `<` 的作用是把命令（或可执行文件）的标准输入重新定向到指定文件，如：

``` bash
$ wc -l < ShowHello.sh
6
$ wc -l ShowHello.sh
6 ShowHello.sh
```

使用 `wc -l` 统计 `ShowHello.sh`这个文件有几行，是否使用输入重定向符并没有太大的差异。

#### 输入重定向符号 `<<`

与输出重定向 `>>` 不同，输入重定向符 `<<` 不代表追加的意思。它的作用是使用特定的分界符作为命令输入的结束标志，而不使用默认的Ctrl+D组合键。

``` bash
$ wc -l << a
> 123
> 456
> abc
> a
3
```

不停的输入，直到输入字符 `a` 之后按回车，才结束输入。上面的 `>` 表示命令没有结束时的换行

#### 输出重定向符 `>`

输出重定向符 `>` 的作用是把命令（或可执行文件）的标准输出重新定向到指定文件（或其他输出目标）。这样，该命令的结果就不在屏幕上显示，而是写入指定文件中（或其他输出目标）。例如：

``` bash
$ ls
ShowHello.sh  bash  filelist.txt  hello.txt  name  note1.txt  test1
d111kc@D111KC:~$ ls > list.txt
d111kc@D111KC:~$ cat list.txt
ShowHello.sh
bash
filelist.txt
hello.txt
list.txt
name
note1.txt
test1
```

将 `ls` 的输出结果写入 `list.txt` 中（这个文件不存在时，会自动创建。文件存在时，会覆盖原文件）。

为了避免原文件内容被覆盖，可以使用输出追加重定向符 `>>`

#### 输出追加重定向符 `>>`

和 `>` 类似，不覆写原文件，而是在原文件的末尾追加新内容。

#### 文件描述符

Linux中一切皆文件，包括标准输人设备（键盘）和标准输出设备（显示器）在内的所有计算机硬件都是文件。在每个进程中，为了表示和区分已经打开的文件，Linux会给每个文件分配一个ID，这个ID就是一个整数，被称为文件描述符（FileDescriptor）。Linux程序在执行任何形式的I/O操作时，都是在读或者写一个文件描述符。在编写程序时，程序员只关注文件的内容。一个文件描述符只是一个和打开的文件相关联的整数，它的背后可能是一个硬盘上的普通文件、FIFO、管道、终端、键盘、显示器，甚至是一个网络连接。在进程创建的时候，系统为每个进程自动打开3个标准文件（即标准输人stdin、标准输出stdout和错误输出stderr），它们默认都是打开
的，其文件描述符分别为0、1、2。在重定向的过程中，0、1、2这3个文件描述符可以直接使用。

标准输出和标准错误输出虽然对应的设备都是显示器，但是它们是两个文件

#### 命令执行操作符

多条命令可以在一行中出现，用命令执行操作符连接，则将按如下规则执行命令：

##### 顺序执行 `;`

如果使用 `;` 连接多条命令，那么这些命令会依次执行，各命令之间没有任何逻辑关系，也就是说，不论哪条命令报错了，后面的命令仍会依次执行。

``` bash
$ ls; date; pwd
ShowHello.sh  bash  filelist.txt  hello.txt  list.txt  name  note1.txt  test1
Fri Aug  1 21:31:32 CST 2025
/home/d111kc
```

它与写成多行的形式是等价的。

##### 逻辑与 `&&`

如果使用 `&&` 连接多条命令，那么这些命令之间就有逻辑关系了。只有第一条命令正确执行了，`&&` 连接的第二条命令才会执行。

##### 逻辑或 `||`

使用 `||` 连接多条命令，则只有前一条命令执行错误，后一条命令才能执行。

##### 小括号`()`和大括号`{}`

当用户登录后启动shell时，这个shell是交互式的。当以这种方式工作时，shell是用户界面，当它执行完一条命令后，接着显示另一个提示符，始终在前台等待用户交互。还有一种shell是非交互的，当在交互shell中运行一个外部命令或者执行一个脚本时，交互shell会创建一个子shell，这个shell在不需要输人的情况下一次性处理所有的命令，运行结束后子shell进程结束。

小括号`()` 和大括号 `{}` 都可以将若干命令括起来，组合在一起，在逻辑上被视为一条命令。使用时在格式上应注意，左括号后面应有一个空格，右括号之前应有一个分号 `;`。大括号也可以包括若干单独占一行的命令，大括号中的命令表必须用分号或者换行符终止。

成组命令也可以用小括号括起来，在成组命令用小括号括起来时，左括号后不必有空格，右括号之前也不需要加上分号。在用于成组命令的执行时，小括号和大括号的主要区别在于：小括号执行成组命令时，重新开启一个子shell来执行；而大括号在执行成组命令时，是在当前shell中执行

##### 管道符、后台命令符和注释符

在shell中，管道符`|`用来连接多条命令，如“命令1丨命令2”。每个命令执行时都有一个独立的进程，前一个命令的输出是下一个命令的输人。这里需要注意，命令1必须有正确输出，而命令2必须可以处理命令1的输出结果；而且命令2只能处理命令1的正确输出，而不能处理错误输出。

为了使这些进程能够在后台运行，可以在命令后面加上`&`，实现后台运行。后台命令符`&`使得在shell中实现多道进程运行成为可能：一个进程在前台运行，其他进程在后台运行。前台进程在执行过程中，用户和进程可以发生交互一一响应用户输人数据，进程处理数据并输出结果，这种方式就是前台方式。后台进程在运行过程中，与用户无交互，即不响应用户的输人和中断控制信号。

适合在后台运行的命令是一些执行时间较长且无交互的命令，如编译程序、费时的排序程序及一些shell脚本。在后台运行作业时要注意，在后台运行的命令一样会将结果输出到屏幕上，干扰用户的工作。如果放在后台运行的作业会产生大量的输出，最好把它的输出重定向到某个文件中。

## shell 编程

shell语法和C语言类似。

### 变量

shell变量分为两类：用户自定义变量和系统预定义的特殊变量。

#### 用户自定义变量

变量名：用户自定义的变量是最普通的shell变量。变量名以字母或下画线开头，由字母、数字和下划线`_`组成。注意，数字不能做变量的开头符，大写字母通常是系统默认的变量，用户自定义变量通常用小写字母。

变量赋值：变量命名后，需要赋值，未赋值的变量其值为空。变量赋值的一般形式为：`变量名=值`。注意，变量与变量内容以等号`=`来连接。赋值时等号两边不能有空格。如果出现空格，赋值语句执行失败，变量未被赋值，依然为空。如果字符串中一定包括空格，字符串要加上引号。

变量引用：在程序中使用变量的值时，要在变量名前面加上`$`符，表示使用变量的值。例如：

``` bash
$ name=d111kc
$ echo $name
d111kc
$ echo name
name
```

在下述情况下，变量的引用会出现歧义：

``` bash
$ dir=/home/student
$ cat $dir01/file1.txt
```

在/home目录下，是以student开头，加学号的学生账户，所以上述命令的本意是要显示`/home/student01/file1.txt`文件，但是shell无法区别变量名是dir还是dir01，在这种情况下，shell默认到第一个非法变量名字符为止，第一个非法变量名字符是/，所以shell认为变量名为dir01，而dir01
未赋值，所以为空，命令执行失败。在这种情况下，要正确引用变量，需要用大括号将该变量名括起来，如下所示：

```
$ cat ${dir}01/filel.txt
```

除了用大括号外，还可以用引号引用变量，上述命令还可以表达成：

``` bash
$ cat "$dir"01/filel.txt
```

需要注意的是，大括号一定不要错写成小括号，`$()`等价于倒引号，其作用是把括号内命令的执行结果赋值给变量，如

```
$ working_dir=$(pwd)
$ echo $working_dir
/home/d111kc
$ echo `pwd`
/home/d111kc
```

数组的定义和使用与变量类似。所谓数组，就是相同数据类型的元素按一定顺序排列的集合，也就是把有限个类型相同的变量用一个名字命名，然后用编号区分它们的变量集合，把这个名字称为数组名，把编号称为下标。组成数组的各个变量被称为数组的元素。但是bash仅支持一维数组（不支持多维数组），并且没有限定数组的大小。数组下标从0开始，不能使用负数下标。

在bash中，用小括号 `()` 来表示包裹数组，数组元素用“空格”分隔。

``` bash
$ langs=(html css javascript)
$ echo ${langs[*]}
html css javascript
$ langs[0]=python
$ langs[1]=c
$ echo ${langs[*]}
python c javascript
```

还可以用declare命令显式声明一个数组，而不赋值，其形式是 `declare -a langs` 这时langs就是一个数组名，而不会被解释成变量了。

通过下标获取数组元素的值 `${数组名[下标]}`，如果没有给出数组元素的下标，则数组名表示下标为0的数组元素。

获取整个数组的值 `${数组名[*]}` 或 `${数组名[@]}`

``` bash
$ langs=(html css javascript)
$ echo ${langs[0]}
html
$ echo $langs
html
$ echo ${langs[*]}
html css javascript
$ echo ${langs[@]}
html css javascript
```

`${langs[*]}` 和 `${langs[@]}` 的区别就是，`${langs[*]}` 将整个数组扩展为一
个词（即字符串），这个词由以空格分开的各个数组元素组成；`${langs[@]}` 将整个数组扩展为多个词，每个数组元素是一个词。例如：

``` bash
$ langs=(html css javascript)
$ for i in "${langs[*]}"; do echo $i; done
html css javascript
$ for i in "${langs[@]}"; do echo $i; done
html
css
javascript
```

代码对数组进行了遍历，`do` 表示循环体的开始，`done` 表示循环体的结束。

#### 系统预定义变量

系统预定义变量是在shell中已定义好的变量，系统预定义变量不能被用户重新定义。

常用的预定义变量：

- `$?` 上一条命令执行后的返回值（也称返回码，退出状态等）
- `$$` 当前进程的进程号（PID）
- `$!` 上一个后台命令对应的进程号（PID）
- `$-` 当前在运行shell程序的选项
- `$#` 命令行上参数的个数
- `$*`，`$@` 命令行上实际给出的所有实参

`$?` 是上一条命令执行后的返回值，它是一个十进制数。大多数的shell命令（除了let命令计算表达式的值等）执行成功后，返回值为0；执行失败，则返回非0值（不同的值代表不同的错误）

``` bash
$ pwd
/home/d111kc
$ echo $?
0
```

`$$` 表示当前进程的进程号。每个进程都有唯一的进程号（PID）

``` bash
$ echo $$
300
```

新开一个终端再次运行上面的命令时，输出的值会发生改变。

`$!` 是上一个后台命令对应的进程号

`$-` 是当前在运行shell程序的选项。shell命令的一般格式是：`命令名 [选项] [参数]` 登录后启动的交互式shell也是一个程序，它和上述命令一样有选项（默认不带参数），它的选项可以通过执行 `echo $-`显示出来：

``` bash
$ echo $-
himBHs
```

#### 位置参数变量

位置参数变量也属于预定义变量。

在Linux的命令行中，当一条命令或脚本执行时，后面可以跟多个参数，使用位置参数变量来表示这些参数。其中，`$0` 代表命令行本身，`$1` 代表第1个参数，依次类推。当参数个数超过10个时，就要用大括号把这个数字括起来，例如，`${10}`；代表第10个参数，`${14}`则代表第14个参数。举个例子：

``` bash
$ cat filel file2
```

在这里，cat对应于`$0`，file1对应于`$1`，file2对应于`$2`

常用的位置参数变量：

- `$n` n为数字，`$0`代表命令本身，`$1` 到 `$9`代表第1—9个参数，10以上的参数需要用大括号包含，如`${10}`
- `$*` 代表命令行中所有的参数，把所有的参数看成一个整体
- `$@` 代表命令行中所有的参数，把每个参数区别对待
- `$#` 命令行上参数的个数

位置参数变量用于向命令或程序脚本传递信息，比如要写一个做加法计算的脚本 `add.sh`，在编写脚本的时候，并不知道add脚本将要处理的数据对象，所以编写代码的时候，以位置参数变量来代替将要处理的数据对象：

``` bash
$ vim add.sh
$ cat add.sh
#! /bin/bash
let num1=$1
let num2=$2
let sum=num1+num2
echo $sum
$ chmod u+x add.sh
$ ./add.sh 1 2
3
```

上面的 `add.sh` 脚本可以带两个参数，脚本根据它们在命令上的位置来识别并予以处理，所以称之为位置参数。

上面的脚本必须传入两个参数，如果想要使用不定长参数，脚本就需要用到循环语句，循环语句需要确定循环的次数，这时候就需要应用`$#`来解决这个问题，`$#`代表命令行上参数的个数，但不包含shell脚本名本身，即不包括`$0`的参数的个数。

除了使用$#来控制循环次数，还可以使用shift来解决这个问题。shift命令移动位置参数，每执行一次shift命令，就把命令行上的实参向左移动一位。注意shift命令不能将$O移走，shift命令执行后，新$1的值是原$2的值，新$2的值是原$3的值，以此类推。例如可以传入不定长参数的加法运算脚本 `add2.sh`：

``` bash
$ vim add2.sh
$ cat add2.sh
#! /bin/bash
let sum=0
while [ $1 ]
do
        let num1=$1
        let sum=num1+sum
        shift
done
echo $sum
$ chmod u+x add2.sh
$ ./add2.sh 1 3 5 7 9
25
```

位置参数除了通过脚本运行时的实参传递赋值外，还可以利用set命令赋值。

#### 环境变量

环境变量也是系统预定义变量，环境变量和用户自定义变量还有一个主要区别就在于，环境变量是全局变量，而用户自定义变量是局部变量。用户自定义变量只在当前的shell中生效，而环境变量会在当前shell和这个shell的所有子shell中生效。

环境变量是写人相应的配置文件的，在执行过程中修改环境变量修改的是进程内存中的变量值，而没有写入配置文件，所以当前shell一旦终止，这个环境变量的修改就会结束，而只有写入配置文件才会在所有shell中生效。

在Linux中一般通过环境变量配置操作系统的环境，如提示符、查找命令的路径、用户家目录等，这些系统默认的环境变量的变量名是固定的，一些环境变量为只读变量，只读变量的值通常是在登录过程中定义的，意味着不能改变这些变量的值；而另一些为非只读变量，可以修改。

环境变量名一般都大写，便于区分。

在bash中可以用env命令列出已经定义的所有环境变量，下面举例说明主要环境变量的
使用。